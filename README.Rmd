---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# GLPKoptimizer

<!-- badges: start -->
[![Lifecycle: experimental](https://img.shields.io/badge/lifecycle-experimental-orange.svg)](https://lifecycle.r-lib.org/articles/stages.html#experimental)
[![R-CMD-check](https://github.com/r-opt/GLPKoptimizer/workflows/R-CMD-check/badge.svg)](https://github.com/r-opt/GLPKoptimizer/actions)
[![Codecov test coverage](https://codecov.io/gh/r-opt/GLPKoptimizer/branch/main/graph/badge.svg)](https://app.codecov.io/gh/r-opt/GLPKoptimizer?branch=main)
<!-- badges: end -->

The goal of `GLPKoptimizer` is to provide [MOI](https://github.com/r-opt/MOI) GLPK bindings.
Still very experimental and incomplete.

`GLPKoptimizer` interacts directly with the solver by creating a pointer to a GLPK instance and
modifying that pointer directly. Most modelling operations are directly passed through to the
solver without making copies of the data in R.

## Installation

You can install the development version of GLPKoptimizer like so:

``` r
remotes::install_github("r-opt/GLPKoptimizer")
```

## Example

You can use `set_irowgen_callback` to register a callback with the solver,
while still being able to use `rmpk`'s modelling features.

```{r example}
library(rmpk)
library(GLPKoptimizer)
solver <- GLPK_optimizer(presolve = TRUE)
model <- optimization_model(solver)
x <- model$add_variable("x", type = "binary", i = 1:10)
model$set_objective(sum_expr(x[i], i = 1:10), sense = "max")
model$add_constraint(sum_expr(x[i], i = 1:10) <= 7.5)

# When an integer solution is found, we dynamically add a constraint
# further restricting the search space.
# In this case, we add another constraint of the sum of x <= 4
set_irowgen_callback(solver, function() {
  values <- vapply(1:10, function(i) {
    # in GLPK you can only access the values of the relaxation
    glpk_get_col_prim(solver, x[i])
  }, numeric(1L))
  all_integral <- all(values %% 1 == 0)
  if (all_integral && sum(values) > 4) {
    model$add_constraint(sum_expr(x[i], i = 1:10) <= 4)
  }
})

model$optimize()
model$get_variable_value(x[i])
```
